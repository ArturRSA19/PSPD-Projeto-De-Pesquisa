#!/usr/bin/env bash
# Execução local dos três serviços com rastreamento de PIDs reais.
set -euo pipefail
ROOT_DIR="$(cd "$(dirname "$0")"/.. && pwd)"

NO_CLEANUP=0
if [ "${1:-}" = "--no-cleanup" ]; then
  NO_CLEANUP=1
fi

if [ -d "$ROOT_DIR/.venv" ]; then
  # shellcheck disable=SC1091
  source "$ROOT_DIR/.venv/bin/activate"
fi

pick_port() {
  local base="$1"; local p="$base"
  while lsof -i tcp:"$p" >/dev/null 2>&1; do p=$((p+1)); done
  echo "$p"
}

USER_PORT=${USER_PORT:-$(pick_port 50051)}
STATS_PORT=${STATS_PORT:-$(pick_port 50052)}
if [ "$STATS_PORT" = "$USER_PORT" ]; then STATS_PORT=$(pick_port $((STATS_PORT+1))); fi
GATEWAY_PORT=${PORT:-$(pick_port 8080)}

export USER_PORT STATS_PORT PORT=$GATEWAY_PORT USER_SERVICE_ADDR="localhost:$USER_PORT" STATS_SERVICE_ADDR="localhost:$STATS_PORT"
echo "[Ports] USER_PORT=$USER_PORT STATS_PORT=$STATS_PORT GATEWAY_PORT=$GATEWAY_PORT"
cat > "$ROOT_DIR/scripts/ports.env" <<EOF
# Auto-generated by run_all_local.sh
USER_PORT=$USER_PORT
STATS_PORT=$STATS_PORT
GATEWAY_PORT=$GATEWAY_PORT
USER_SERVICE_ADDR=$USER_SERVICE_ADDR
STATS_SERVICE_ADDR=$STATS_SERVICE_ADDR
EOF
echo "[Ports] Arquivo scripts/ports.env criado para uso em testes de performance."

PIDS=()

start_service_a() {
  echo "[Service A] iniciando na porta $USER_PORT..."
  (
    cd "$ROOT_DIR/service-a-python"
    # Se não houver venv local, cria
    if [ ! -d .venv ]; then
      python3 -m venv .venv >/dev/null 2>&1 || python -m venv .venv
    fi
    # shellcheck disable=SC1091
    source .venv/bin/activate
    # Instala requirements se grpc não disponível
    python -c "import grpc" 2>/dev/null || {
      echo "[Service A] Instalando dependências Python..."
      pip install -q --upgrade pip
      if [ -f requirements.txt ]; then
        pip install -q -r requirements.txt
      else
        pip install -q grpcio protobuf
      fi
    }
    exec python server.py
  ) &
  PIDS+=("$!")
  local last_index=$(( ${#PIDS[@]} - 1 ))
  echo "${PIDS[$last_index]}" > /tmp/pspd_service_a.pid
}

start_service_b() {
  echo "[Service B] iniciando na porta $STATS_PORT..."
  ( cd "$ROOT_DIR/service-b-go" && STATS_PORT=$STATS_PORT go run . ) &
  PIDS+=("$!")
  local last_index=$(( ${#PIDS[@]} - 1 ))
  echo "${PIDS[$last_index]}" > /tmp/pspd_service_b.pid
}

start_gateway() {
  cd "$ROOT_DIR/gateway-node"
  if [ ! -d node_modules ]; then
    echo "[Gateway] instalando dependências..."
    npm install --no-audit --no-fund >/dev/null
  elif [ ! -d node_modules/ws ]; then
    echo "[Gateway] instalando 'ws'..."
    npm install ws --no-audit --no-fund >/dev/null
  fi
  echo "[Gateway] iniciando na porta $GATEWAY_PORT..."
  ( PORT=$GATEWAY_PORT USER_SERVICE_ADDR=$USER_SERVICE_ADDR STATS_SERVICE_ADDR=$STATS_SERVICE_ADDR npm start ) &
  PIDS+=("$!")
  local last_index=$(( ${#PIDS[@]} - 1 ))
  echo "${PIDS[$last_index]}" > /tmp/pspd_gateway.pid
  cd "$ROOT_DIR"
}

cleanup() {
  if [ "$NO_CLEANUP" = 1 ]; then return; fi
  echo "\nEncerrando processos..."
  for p in "${PIDS[@]:-}"; do
    if kill -0 "$p" 2>/dev/null; then kill "$p" || true; fi
  done
}
trap cleanup EXIT INT TERM

start_service_a
start_service_b
start_gateway

sleep 2
echo "\nServiços iniciados (PIDs reais):"
ps -o pid,command -p $(cat /tmp/pspd_service_a.pid) $(cat /tmp/pspd_service_b.pid) $(cat /tmp/pspd_gateway.pid) || true

echo "\nTestes rápidos:" 
echo "curl http://localhost:$GATEWAY_PORT/healthz"
echo "curl http://localhost:$GATEWAY_PORT/users/1"
echo "WebSocket: ws://localhost:$GATEWAY_PORT/chat"
echo "Página Chat: http://localhost:$GATEWAY_PORT/chat-test"

echo "Pressione Ctrl+C para encerrar (ou use --no-cleanup para deixar rodando)."
wait
